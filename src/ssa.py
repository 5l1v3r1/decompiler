""" Transform the program flow in SSA form.

"""

from statements import *
from expressions import *

import filters.simplify_expressions

class alternate_form_iterator_t(object):
  """ Finds all alternate forms of `expr`.

    For example, if the expression `*(a@1 + 4)` is given, and `a@1` is defined as
    `a@1 = s@0 + 4` then the iterator will yield `*(s@0 + 8)` as an alternate form.

    Alternate forms are generated by replacing all operand uses by their
    definitions in the given expression, so this can only be called on an
    expression after registers have been tagged by the ssa tagger.
  """

  def __init__(self, expr, include_self=False):
    self.expr = expr
    self.include_self = include_self
    self.alternate_forms = []
    self.visited_tetha = []
    return

  def found_alternate(self, alternate, visited):
    new = filters.simplify_expressions.run(alternate, deep=True)
    if new in self.alternate_forms:
      return
    self.alternate_forms.append(new)
    if not visited:
      self.unexplored.append(new)
    yield new

  def __iter__(self):
    cp = self.expr.copy()
    cp.index = None

    self.alternate_forms = [cp]
    self.unexplored = [cp]

    if self.include_self:
      yield cp

    while len(self.unexplored) > 0:
      current = self.unexplored.pop(0).copy()

      for op in current.iteroperands():
        if isinstance(op, deref_t) or \
            not isinstance(op, assignable_t) or \
            not op.definition or \
            not op.definition.is_def:
          continue

        value = op.definition.parent.op2

        if op not in self.visited_tetha:
          self.visited_tetha.append(op.copy())

        if type(value) == theta_t:
          _op = op
          for thetaop in value:
            newop = thetaop.copy()
            _op.replace(newop)
            _op = newop
            visited = _op in self.visited_tetha
            for found in self.found_alternate(current.copy(), visited):
              yield found
        else:
          op.replace(value.copy())
          for found in self.found_alternate(current.copy(), False):
            yield found

        _continue = True

    return

class defined_loc_t(object):

  def __init__(self, block, loc):
    self.block = block
    self.loc = loc
    self.cleanloc = loc.copy()
    self.cleanloc.index = None
    #self.alt_forms = []
    #self.find_alt()
    return

  def __eq__(self, other):
    return type(other) == defined_loc_t and other.loc == self.loc

  def __ne__(self, other):
    return not (self == other)

  def is_definition_of(self, other):
    for alternate1 in alternate_form_iterator_t(other, include_self=True):
      for alternate2 in alternate_form_iterator_t(self.loc, include_self=True):
        if alternate1 == alternate2:
          return True
    return False

class ssa_context_t(object):

  def __init__(self):
    self.defined = []
    return

  def copy(self):
    ctx = ssa_context_t()
    ctx.defined = self.defined[:]
    return ctx

  def get_definition(self, block, expr):
    obj = self.get_definition_object(block, expr)
    if obj:
      return obj.loc
    return

  def get_definition_object(self, block, expr):
    expr = expr.copy()
    expr.index = None

    for _loc in self.defined:
      if _loc.is_definition_of(expr):
        return _loc

    return

  def add_uninitialized_loc(self, block, expr):
    loc = defined_loc_t(block, expr)
    self.defined.append(loc)
    return

  def assign(self, block, expr):
    loc = defined_loc_t(block, expr)
    obj = self.get_definition_object(block, expr)
    if obj:
      self.defined.remove(obj)
    self.defined.append(loc)
    return

SSA_STEP_NONE = 0
SSA_STEP_REGISTERS = 1
SSA_STEP_DEREFERENCES = 2

class ssa_tagger_t(object):
  """
  """

  def __init__(self, flow):
    self.flow = flow

    self.tagger_step = SSA_STEP_NONE

    self.index = 0

    # keep track of any block which we have already walked into, because at
    # this stage we may still encounter recursion (gotos that lead backwards).
    self.done_blocks = []

    # list of `assignable_t` that are _never_ defined anywhere within
    # the scope of this function.
    self.uninitialized = []

    #~ # map of `flowblock_t`: `ssa_block_contexts_t`. this is a copy of the
    #~ # context at each statement. this is useful when trying to
    #~ # determine if a register is restored or not, or which locations
    #~ # are defined at a specific location.
    #~ self.block_context = {}

    #~ # list of `statement_t`
    #~ self.theta_statements = []
    #~ # dict of `assignable_t`: `theta_t`
    #~ self.theta_map = {}

    # dict of `flowblock_t` : [`expr_t`, ...]
    # contains contexts at the exit of each block.
    self.exit_defines = {}

    # dict of `flowblock_t` : [`expr_t`, ...]
    # contains each block and a list of thier theta assignments.
    self.block_thetas = {}

    return

  def is_correct_step(self, loc):

    if not isinstance(loc, assignable_t):
      return False

    if isinstance(loc, regloc_t) and self.tagger_step == SSA_STEP_REGISTERS:
      return True

    if isinstance(loc, deref_t) and self.tagger_step == SSA_STEP_DEREFERENCES:
      return True

    return False

  def get_defs(self, expr):
    return [defreg for defreg in expr.iteroperands() if self.is_correct_step(defreg) and defreg.is_def]

  def get_uses(self, expr):
    return [defreg for defreg in expr.iteroperands() if self.is_correct_step(defreg) and not defreg.is_def]

  def same_loc(self, a, b):
    return a.clean() == b.clean()

  def tag_uninitialized(self, expr):
    found = False
    for loc in self.uninitialized:
      if self.same_loc(loc, expr):
        expr.index = loc.index
        return

    expr.index = self.index
    self.index += 1
    self.uninitialized.append(expr)
    return

  def insert_theta(self, block, lastdef, thisdef):

    newuse = self.clean_du(lastdef.copy())
    stmt = statement_t(assign_t(self.clean_du(thisdef.copy()), theta_t(newuse)))
    block.container.insert(thisdef.parent_statement.index(), stmt)

    if lastdef.is_def:
        self.link(lastdef, newuse)

    return stmt

  def need_tetha(self, context, block, expr):
    obj = context.get_definition_object(block, expr)
    return obj and obj.block != block

  def tag_use(self, context, block, expr):
    if self.need_tetha(context, block, expr):
      # expr is defined in another block.

      lastdef = context.get_definition(block, expr)
      if lastdef:
        stmt = self.insert_theta(block, lastdef, expr)

        self.block_thetas[block].append(stmt)

        context.assign(block, stmt.expr.op1)
        stmt.expr.op1.index = self.index
        self.index += 1

        expr.index = stmt.expr.op1.index
        self.link(stmt.expr.op1, expr)
        return

    lastdef = context.get_definition(block, expr)
    if lastdef:
      # the location is previously defined.
      expr.index = lastdef.index
      self.link(lastdef, expr)
    else:
      # the location is not defined, it's external to the function.
      self.tag_uninitialized(expr)
      context.add_uninitialized_loc(block, expr)

    return

  def link(self, d, u):
    d.uses.append(u)
    u.definition = d
    return

  def clean_du(self, loc):
    loc.uses = []
    loc.definition = None
    return loc

  def tag_tethas(self, context, block):
    """ insert new locations from the current context in all
        theta-functions present in the target block. """
    for stmt in self.block_thetas[block]:
      loc = stmt.expr.op1
      lastdef = context.get_definition(block, loc)
      if lastdef and lastdef != loc:
        newuse = self.clean_du(lastdef.copy())
        stmt.expr.op2.append(newuse)
        self.link(lastdef, newuse)
    return

  def tag_uses(self, context, block, expr):
    for use in self.get_uses(expr):
      if use.index is None:
        self.tag_use(context, block, use)
    return

  def tag_defs(self, context, block, expr):
    for _def in self.get_defs(expr):
      context.assign(block, _def)
      _def.index = self.index
      self.index += 1
    return

  def tag_block(self, context, block):

    if block in self.done_blocks:
      self.tag_tethas(context, block)
      return

    self.done_blocks.append(block)
    self.block_thetas[block] = []

    for stmt in list(block.container.statements):
      for expr in stmt.expressions:
        self.tag_uses(context, block, expr)
        self.tag_defs(context, block, expr)

      if type(stmt) == goto_t:
        target = self.flow.get_block(stmt)
        self.tag_block(context.copy(), target)
      elif type(stmt) == branch_t:
        for expr in (stmt.true, stmt.false):
          target = self.flow.get_block(expr)
          if target:
            self.tag_block(context.copy(), target)
      elif type(stmt) == return_t:
        break

    return

  def tag_registers(self):
    self.done_blocks = []
    self.tagger_step = SSA_STEP_REGISTERS
    context = ssa_context_t()
    self.tag_block(context, self.flow.entry_block)
    return

  def tag_derefs(self):
    self.done_blocks = []
    self.tagger_step = SSA_STEP_DEREFERENCES
    context = ssa_context_t()
    self.tag_block(context, self.flow.entry_block)
    return

  def tag(self):
    self.tag_registers()
    self.tag_derefs()
    return
